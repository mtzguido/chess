\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{fullpage}
\usepackage{hyperref}

\renewcommand{\refname}{\section{Referencias}}

\begin{document}

\title{Proyecto IIA - Motor de Ajedrez}

\author{Guido Martínez \\ LCC, FCEIA, UNR }

\maketitle

\section{Objetivo}

Crear una inteligencia artificial para jugar al ajedrez (un \emph {Motor
de Ajedrez}, usando métodos tradicionales. Priorizar el entendimiento
y claridad del código ante la performance, siempre que esto no haga a
nuestro motor demasiado lento como para competir con otros.

\section{Overview}

Como es usual, el algoritmo de búsqueda elegido es Alpha-Beta con una
búsqueda de quietud (\emph{Quiescence Search}) en los nodos terminales
de la búsqueda.
También se incluye un límite de tiempo para que una movida no tarde
una cantidad exagerada de tiempo.
\\

Lo que mayormente define al motor son la representación del tablero,
las heurísticas de ordenamiento de movidas, las reducciones y
extensiones de búsqueda, y la evaluación de tablero.

Pasamos a detallar esas categorías para nuestro motor
\\

\subsection{Representación de tablero}
Se usa un array de 8x8 con las piezas. También se usan máscaras
de 64 bits para acelerar algunos cálculos. En la estructura del
tablero, además de estar la información del juego en sí, se mantienen
incrementalmente (se ajustan/recalculan luego de cada movida):

\begin{itemize}
\item Puntaje de piezas de cada lado
\item Un hash del tablero para comparar rápidamente por igualdad
\item Los puntajes pieza-posición
\item Las máscaras previamente mencionadas
\end{itemize}

Se mantienen estos datos incrementalmente para no tener que recorrer
todo el tablero al momento de la evaluación para calcularlos. El hash
fue específicamente elegido debido a que su cálculo es incremental
con cada movida y da muy buenos resultados (\emph{Zobrist hashing}
\cite{zobrist}).

\subsection{Heurísticas de ordenamiento de movidas}
En orden de importancia (puntaje que aportan al ordenamiento):
\begin{itemize}
\item Tablas de transposición
\item Killer Move Heuristic
\item Countermove Heuristic
\item MVV-LVA
\end{itemize}

\subsection{Reducciones}

\begin{itemize}
\item Null-move heuristic (para nodos \emph{fail-high})
\item Late move reduction (para nodos \emph{fail-low})
\end{itemize}

\subsection{Extensiones}
\begin{itemize}
\item Extensión por jaque
\item Extension por promoción
\end{itemize}

\subsection{Evaluación del tablero}
Para la evaluación del tablero se tienen en cuenta:
\begin{itemize}
\item Puntaje de piezas
\item Puntaje pieza-posición
\item Estado de jaque
\item Estado de filas
\item Estado de enroque
\item King-safety
\end{itemize}

Las tablas pieza-posición fueron tomadas de \cite{piece-square-table} y ligeramente modificadas.\\

\section{Diseño general}

Habiendo tantos motores de Ajedrez hechos, hay mucho material para
investigar. La mayoría de los motores optan por tener un sólo tablero
del juego en memoria (representado de diversas formas), y una \emph
{Pila de Historia} (\emph {History Stack}) con información para
deshacer las movidas hechas. Yo opté por copiar el tablero original,
realizar la movida sobre la copia y luego descartar la copia al terminar
de usarla.
\\

Los motores realizan una búsqueda sobre un grafo \emph{implícito},
en donde el nodo actual es siempre el tablero en cuestión (el
único en memoria). A este tablero se le generan las movidas
\emph{pseudo-sucesoras}. Cada una de estas movidas es evaluada y
puntuada para hacer un ordenamiento (dado que el algoritmo Alpha-Beta
funciona mejor cuando las mejores movidas son evaludas primero). Una vez
ordenadas por puntaje, la búsqueda prosige hasta alguna profundidad.
\\

Por pseudo-sucesoras nos referimos a que se consideran algunas movidas
que pueden no ser realmente válidas, como por ejemplo alguna movida que
deje al jugador en jaque. La razón de esto es que para verificar que
una movida es realmente válida debemos hacer bastante trabajo, y por la
naturaleza del Alpha-Beta es probable que aunque generemos 30 sucesores,
encontremos un corte mucho antes de llegar al último, por lo cual ese
trabajo nunca se haría.
\\

\section{Detalles}
Detallamos las técnicas usadas que son relevantes a la materia.

\subsection{Algoritmo Alpha-Beta}

El algoritmo Alpha-Beta es una mejora al algoritmo clásico Minimax,
que resuelve juegos de suma-cero (rápidamente, aquellos en que una
ganancia de un jugador es una pérdida directa del otro). Minimax puede
usarse para juegos en que las partes ``mueven'' al mismo tiempo, pero
ignoraremos eso y nos concentraremos en su aplicación para este juego.
\\

El Minimax más básico funciona explorando el árbol de movidas del
juego, de a un turno, considerando todas las movidas posibles de cada
jugador, hasta llegar a un nodo terminal (juego finalizado). Cada nodo
terminal tiene un puntaje asociado según quien ganó. Para el Ajedrez,
podría ser 1 cuando ganan las blancas, -1 cuando ganan las negras y 0
cuando empatan. Minimax nos devolverá el puntaje que podemos conseguir
y la movida que debemos jugar.
\\

Hacer una búsqueda hasta los nodos terminales no funciona para juegos
con un tamaño mayor al Ta-Te-Tí (y aún ahí se nota cierta lentitud)
debido a la cantidad de nodos explorados. Recordando el factor de
ramificación promedio de 30 y las 80 media-movidas (movidas por
jugador) por partido del Ajedrez esto resulta impracticable. Por
está razón se agrega un límite de profundidad, y si llegamos a él
devolvemos un \emph{valor heurístico} del tablero, que representa
de alguna manera el puntaje de cada jugador. Con ésta modificación
Minimax nos devolverá un ``valor esperado'' y la movida que debemos
hacer.
\\

Está evaluación de tablero guiará la búsqueda casi en su
totalidad, por lo cual es necesario que realmente se corresponda con
la situación y dé puntajes adecuados según quién va ganando.
También es necesaria cierta estabilidad de esta función. Citando a
\href{http://chessprogramming.wikispaces.com/}{chessprogramming.wikispaces.com}:
\\

\noindent
\framebox{\parbox{\dimexpr\linewidth-2\fboxsep-2\fboxrule}{\itshape\center
	``It is better to be wrong by 10 centipawns all the time than to be
	completely correct 99.9\% of the time and wrong by 300 centipawns 0.1\% of
	the time.''
}}
\\

El algoritmo Minimax tiene una peculiaridad, si al analizar la primera
movida que podemos hacer generamos un jaque mate (el mejor resultado
posible), la búsqueda seguirá y calculará los valores esperados de
todos los nodos del árbol. Este caso particular podría detectarse y
mejorarse, pero hay una idea aún mejor que da resultados muchísimo
mejores: la poda Alpha-Beta.
\\

El algoritmo Alpha-Beta extiende al Minimax llevando cuenta de una
``ventana'' de búsqueda. Dos valores llamados Alpha y Beta que
representan respectivamente los puntajes ``garantizados'' del jugador
maximizante y minimizante. Por garantizado se entiende a que el jugador
puede ``forzar'' un resultado de al menos ese puntaje. Ambos se inician
en el peor resultado posible ($-\infty$ y $+\infty$ respectivamente)
y se actualizan en la búsqueda. Si en algún vemos que una movida
del jugador maximizante resulta en un puntaje mayor a Beta, podemos
asegurar que esta rama que estamos explorando no tiene sentido, debido
a que jugador minimizante seguiría otra rama (la que le da el puntaje
garantizado) en vez de la actual.
\\

El mismo corte puede ocurrir en turnos del jugador minimizante. El
algoritmo Alpha-Beta siempre da el mismo resultado que Minimax,
pero su complejidad temporal promedio disminuye de $O(b^d)$ a
$O(b^{(3d/4)})$\footnotemark. Lo que significa que podemos hacer una
búsqueda un 33\% mas de profundidad en el mismo tiempo. La complejidad
en el peor caso se mantiene ($O(b^d)$) y la del mejor caso es aún
mejor: $O(\sqrt{b^d})$. El peor y mejor caso dependen de la cantidad de
cortes que encuentre el algoritmo.
\\

\footnotetext{$b$ es el factor de ramificación promedio y $d$ la
profundidad de la búsqueda}

Estos cortes tienden a ocurrir más frecuentemente si las mejoras
movidas de cada jugador se analizan primero. Para lograr esto se emplean
muchas heurísticas de ordenamiento de movidas.
\\

\subsection{Killer move heuristic}
Una de las heurísticas de ordenamiento de movidas mas simple y
rendidora es la Killer move heuristic. Consiste en guardar en una tabla
la movida que generó un corte, indexada por la profundidad en la cual
se hizo la movida.
\\

\subsection{Tabla de transposición}
La tabla de transposición es la manera de eliminar nodos duplicados
en la búsqueda. Al usar Alpha-Beta no podemos simplemente guardar el
resultado que devolvimos, si no que también hay que tener en cuenta el
contexto en el cual lo generamos, y saber si estamos tratando con un
resultado exacto, o una cota superior o inferior.
\\

TBD
\\

\subsection{Countermove heuristic}
Es una heurística similar a la Killer Move, pero en vez de registrar
los cortes indexados por la profundidad de la búsqueda, lo hace según
la movida realizada anteriormente a la actual, bajo la premisa de que
hay movidas que tienen una ``respuesta natural'' independientemente de
la profundidad y el tablero. Da resultados no muy buenos, pero es fácil
de implementar.
\\

\subsection{MVV-LVA}
MVV-LVA significa ``\emph{Most valuable victim, least valuable
attacker}'', es una heurística simple que puntúa las capturas. Una
captura es mejor que otra si captura a una pieza de mayor valor, o
realiza la captura con una pieza propia de menor valor. La fórmula
usada para puntuar es $10*v - a$ en donde $v$ es el puntaje de la pieza
víctima y $a$ el puntaje de la pieza atacante.
\\

Funciona bastante bien para ser algo tan simple de implementar. En
especial para la búsqueda de quietud, en donde sólo consideramos las
capturas. Hace una diferencia muy importante en ese caso debido a que no
tenemos un límite de profundidad como en la búsqueda principal.
\\

\section{Resultados}
Proximamente

\section{Reflexiones}
Hay varias decisiones de diseño que me gustaría cambiar, pero a esta
altura ya resulta muy laborioso. La primera es la decisión de no usar
un único tablero con una Pila de Historia. Creo que esto es bastante
más benefioso que lo hecho debido a que la copia de todo el tablero es
probablemente mas lenta que hacer la movida y retractarla. A su vez,
creo que se beneficiaría de la localidad de caché de los procesadores.
Este es claramente un lugar para una mejora futura.
\\

Sin duda algo a mejorar es la evaluación de tablero. Escribir una buena
función de evaluación de tablero requiere muchísimo conocimiento
del dominio, y por lo general es llevado a cabo por expertos en el
juego junto a programadores. Sin duda, yo no tengo un nivel ni siquiera
intermedio del juego, por lo cual me limité a leer y aplicar técnicas
existentes y bien conocidas.
\\

Se podría paralelizar la búsqueda, aunque esto es algo no trivial
debido a la naturaleza secuencial del Alpha-Beta. Al paralelizar
seguramente exploraríamos mas nodos que de forma secuencial, debido a
que no conoceremos exactamente la ventana en la cual tenemos que buscar.
Sin embargo, creo que se verían mejoras notables.
\\

Otras mejoras pueden ser hacer que el límite de tiempo sea algo más
inteligente (tener en cuenta cuanto tiempo lleva usado cada jugador,
y el límite del partido, si es que existe) y hacer que nuestro motor
``piense'' durante el turno del otro (conocido como \emph{Pondering}).
\\

\begin{thebibliography}{9}

\bibitem{piece-square-table}
  http://chessprogramming.wikispaces.com/Simplified+evaluation+function

\bibitem{zobrist}
  http://en.wikipedia.org/wiki/Zobrist\_hashing

\end{thebibliography}

\end{document}
